## 程序功能介绍

该项目的目的是实验音乐的频谱展示，在播放的过程中，计算出频谱，并且用图像显示出来，使得音乐中每个时刻每个频率的变化都能用眼睛看到。总体来说该项目实现的功能有：

1. 读取音乐文件，并调用现有的开源解码算法进行解码，尽可能支持多一点的音频格式（如 mp3、wav等）。
2. 应用自己设计的频谱分析算法，计算出音乐的每个时刻的每个频率的振幅，用图像表达出来（例如可以用颜色深度表达，可以用条形统计图表达）。
3. 播放音乐的过程中，实时用某种方式显示频谱，可以设计多种显示方式，让用户自由选择显示方式。



## 公式推倒（从 DFT 开始）

### 离散傅里叶变换（DFT）公式：

$$X(k) = \sum\limits_{n = 0}^{N - 1} {x(n)W_N^{nk}} ,k = 0,1,...,N - 1$$
其中，${W_N^{nk}}$为旋转因子，$W_N^{nk} = {e^{ - j{{2\pi } \over N}nk}},n = 0,1,...,N - 1$

### 计算其模长
$$\eqalign{
  & X(k)  \cr 
  &  = \sum\limits_{n = 0}^{N - 1} {x(n)W_N^{nk}}   \cr 
  &  = \sum\limits_{n = 0}^{N - 1} {x(n){e^{ - j{{2\pi } \over N}nk}}}   \cr 
  &  = \sum\limits_{n = 0}^{N - 1} {x(n)\left( {\cos \left( {{{2\pi } \over N}nk} \right) - i\sin \left( {{{2\pi } \over N}nk} \right)} \right)}   \cr 
  &  = \sum\limits_{n = 0}^{N - 1} {\left( {x(n)\cos \left( {{{2\pi } \over N}nk} \right) - ix(n)\sin \left( {{{2\pi } \over N}nk} \right)} \right)}   \cr 
  &  = \sum\limits_{n = 0}^{N - 1} {x(n)\cos \left( {{{2\pi } \over N}nk} \right)}  - i\sum\limits_{n = 0}^{N - 1} {x(n)\sin \left( {{{2\pi } \over N}nk} \right)}   \cr }$$
所以 $\left| {X(k)} \right| = \sqrt {{{\left( {\sum\limits_{n = 0}^{N - 1} {x(n)\cos \left( {{{2\pi } \over N}nk} \right)} } \right)}^2} + {{\left( {\sum\limits_{n = 0}^{N - 1} {x(n)\sin \left( {{{2\pi } \over N}nk} \right)} } \right)}^2}} $

### 该模长的物理意义

从我们所学习的信号知识，很容易得出：假设x()数组为N个样点的离散信号，那么，$\left| {X(k)} \right|$的值所表示的物理意义为

在整个样本中振动 k 次对应的频率的振幅为 ${{2\left| {X(k)} \right|} \over N}$

### 如何利用此物理意义计算出音乐的频谱

假设一首歌的频谱是一副二维图像，横轴为频率，范围是20~20000HZ，纵轴为时间，范围是整首歌的样点数对应的时间（总时长秒数=样点数/采样率），所表示颜色深度值为该时刻下该频率的振幅

而该公式仅仅能计算一小范围样点的每个频率的振幅，如果把这一范围作为所取的窗口，用窗口移动的方式计算出一首歌中每个时刻对应的所有频率是振幅的话，会产生以下问题：

1. 如果窗口过大，虽然检测出来的频率准确，但是会导致时间刻度上不够精细。
2. 如果窗口过小，虽然时间刻度上精细，但是会导致频率刻度上不够精细。

也就是说，如果固定窗口检测，要么频率精度和时间精度难以两全其美。

### 为什么从  DFT  公式开始推倒而不是  FFT

FFT（快速傅里叶变换）是目前常用的频谱分析算法，他是 DFT 经过优化所设计的蝶形算法。由于 FFT 输入的窗口大小样点数是固定的2的整数次幂，蝶形算法的精髓在于从2的一次幂对应的样点数开始递推，指数增加时可以由低一级的指数乘积而来，很大程度优化固定的2次幂样点数的窗口的频谱计算效率。

对于一首歌曲，我们需要想办法在频率精度和时间精度两全其美的话，就需要设计一种可变窗口移动最终取最值的算法计算出频谱，才能确保两全其美，如果用 FFT 算法的话，则需要多次变化窗口多次计算FFT，此时蝶形算法固定窗口将失去意义反而增加计算累赘，还不如用 DCT，重新设计出一个算法，自己对其效率进行优化。



## 算法可行性思考以及优化思路

### 变化窗口取最值的算法思路

由于固定窗口的 DCT 算法在时间、频率两刻度上的精度难以两全其美，就有了变窗口多次DCT计算取最值的思路：

1. 对于一个特定频率特定时刻，从最小窗口（一个周期对应的样点）开始，窗口从包含该时刻的最左端进行DCT计算，并且开始移动，移动到最右端包含该时刻的窗口，也就是一共移动了两个周期对应的样点数的次数，进行了两个周期样点数的次数的DCT计算，对这些DCT的结果取最大值。
2. 慢慢增大窗口大小（可两倍两倍加）到固定上限，假设上限为 ${2^{MAX\_WIN\_N\_VIB\_P}}$ ，反复照步骤1移动窗口计算取得最大值，然后得到若干个最大值，取这些最大值中的最小值，作为最终结果。

### 原始算法不经过优化的时间复杂度分析

对于特定频率特定时刻，假设固定窗口大小上限为一个周期的 $${2^{p - 1}}$$ 倍，一个周期包含的样点数为N，根据上述推倒的DCT公式容易得出一次DCT算法的时间复杂度为o(N)，最小窗口移动 2N 次，也就是进行了 2N 次 DCT 运算，乘起来得一共需要 $N*2N$ 次。

窗口大小乘以2再进行上述循环DCT运算，包含两个周期，每次要进行 4N 次运算，一共需要循环 $2N*4N$ 次，以此类推再乘以2需要进行的循环次数为 $4N*8N$ 次，直到最大周期时需要循环 $pN*2pN$ 次。

所以一共需要的计算次数为 $$N*2N + 2N*4N + ... + {2^p}N*{2^{p + 1}}N$$ 次，时间复杂度远大于 O(${p^2}{N^2}$)

而这只是计算特定频率特定时刻的复杂度，要是要从20HZ计算到20000HZ的话，又得乘以频率刻度，这是目前计算机所不能承受的计算量。

### 算法优化思路

1. 在计算低频率的振幅时，由于低频的周期长，一个周期所包含的样点数大，也就是N大，将窗口每次移动 1/N 个周期，得到的变化实在是小，而最终要取的是最大值，所以不需要分那么细，也就是没必要将N个样点每个窗口都要移一次，可以定义一个周期最大分割粒度的概念，周期最大分割粒度即最大能将一个周期分割为 ${2^{MAX\_T\_SEG\_P}}$ 倍，MAX_T_SEG_P 代表周期分割粒度，可以将此作为一个常量，由于 MAX_T_SEG_P 的限制，窗口移动的次数最多为 ${2^{MAX\_T\_SEG\_P + 1}}$ 次，能优化一个档次。其中 MAX_T_SEG_P 越大低频计算效果越精细计算复杂度越高，可以多次实验得出最佳 MAX_T_SEG_P 值。
2. DCT公式中有三角函数的计算，由于 c 语言标准库的sin、cos内部实现是用的泰勒展开然后求和的，而我们的算法要频繁调用这两个三角函数，将会导致非常频繁的泰勒展开然后求和，成为算法效率的瓶颈，而我们并没有必要如此重复和精细。根据三角函数的周期性可以简化重复运算，我们可以将一个圆分成足够多的份数，假设分为 MAX_N_DIV_CIRCLE 份，然后设计一个数组 double sin_o[MAX_N_DIV_CIRCLE]，在程序运行的初期就给这个数组填充好数值： sin_o[i] = sin(2\*PI\*i/MAX_N_DIV_CIRCLE) ，然后真正要计算 sin(x) 的时候，可以用 sin_o[x\*m%MAX_N_DIV_CIRCLE\] 代替，cos函数类似。也就是将原来泰勒展开循环累加的算法简化成了乘法取模再寻址，极大提高效率。其中 MAX_N_DIV_CIRCLE 越大低频三角函数计算效果越精细占内存越多，可以多次实验得出最佳 MAX_N_DIV_CIRCLE 值。
3. DCT算法的本质是傅里叶变换的卷积得来的，其中卷积就是以三角函数作为卷积和，上述公式中由于求的是正余弦函数的卷积的平方和，所以三角函数的相位并不会对最终结果产生影响，从这个角度出发，在一个特定频率下的一条频谱线上，我们画一条固定的正弦函数，平移1/4个周期作为余弦函数，可以提前计算出这条线所有点与相应的三角函数的乘积 m_sin[i]，最终再累加得到卷积结果再求平方和作为最终结果，这样的提前计算可以免去循环中大量的重复计算，使得效率提升。
4. 在优化思路 3 中，假设已经求出了一条频率线上所有点与对应三角函数的乘积，组成了一个数组 m_sin[i]，后续的卷积要把这些乘积结果求和，而且随着窗口大小变化，随着窗口移动，求和的区间是不同的，但是共同特点都是对这个数组中的连续子元素求和，我们可以用动态规划的思想，储存这个中间结果，即用 sum_m_sin[i,j] 表示 从 m_sin[i] 加到 m_sin[i+j-1] 的总和，然后把 sum_m_sin 存好供后续随时使用，而 sum_m_sin 数组可以很容易的通过递推算法得出，总的来说这个优化思路就是以空间代价换时间代价，两个周期下占用的内存为 ${4^{MAX\_WIN\_N\_VIB\_P+MAX\_T\_SEG\_P}}$*sizeof(double)，递推算法复杂度为 O(窗口内包含的样点数^2)。
5. 在优化思路 4 中，低频下周期长度大，窗口内包含的样点数过多，可能会导致算法复杂度过高，比如一秒内就包含44100个样点，一平方的话显然计算量大。考虑到我们没必要求出每个样点处对应的频率振幅值，而只需要求出特定时间刻度的每个刻度下的频率值，而这个刻度是自己定义的，比如一秒钟显示60帧。为了简化计算，考虑每次只需要平移一帧，这样一来，窗口大小就不是周期的整数倍了，还需要规定一个窗口内最少包含的周期数。
6. 公式中的计算平方和再开根号，再求最大值，由于根号函数是增函数，开根号不影响大小顺序，所以可以先求出平方和的最大值，只需要对最大值开根号，也就省去了很多开根号运算。
7. 对于高频率段，比如2000HZ，即一秒钟里面两千个周期，那么窗口移动的过程中，求出每个两千分之一秒，即每0.5毫秒的振幅，那么精细显然是没有必要的，因为人眼分辨不出那么精细的变化，对于我们普通的肉眼来说60帧可能就已经很流畅了，所以可以设定一个帧率上限，减少计算量。

经过上述优化，所有步骤都变成了线性的算法，计算一个特定时刻特定频率的振幅的算法的时间复杂度被降低到 O(${2^{MAX\_WIN\_N\_VIB\_P+MAX\_T\_SEG\_P}}$)。



## 程序架构设计

### 两种架构的提出

该项目的最终目的是音乐播放器播放的过程中显示出频谱，频谱随着播放进程而动，也就是播放到哪个时刻，就显示出哪个时刻的从20HZ～20000HZ的振幅。

该算法在此项目中的体现，可以有两种设计：

1. 在播放器加载音频文件后就开始对整个文件解码，把解码的结果再经过该算法计算，计算出每个时刻每个频率的振幅，把计算结果存到一个很大的二维数组里，播放的时候可以随时访问二位数组的每个元素。
2. 讲播放器设计为一边播放一边读取文件一边解码一边算法计算，播放到某个时刻时提前解码和计算好后一段时间的频谱供播放和显示，确保能够流畅播放和显示。

### 第一种架构的可行性思考

第一种架构需要读取整个文件，对整个文件解码，然后计算出频谱。现在假设有一首普通的歌曲音频mp3文件的大小为5兆，采样率为44100HZ，比特率为192kbps，从空间和时间复杂度两方面进行分析：

1. 192kbps即每秒钟192000位，也就是24000个字节，用5兆除以这个数得到总秒数为218.45秒，再乘以采样率得到总样点个数为9633645个，每个样点用一个double类型表示即 9633645\*8=77069160字节，即73.5mb，我们再设频率精度为一个半音，即频率的每个刻度呈 ${2^{{1 \over {12}}}}$ 倍增长，从20HZ~20000HZ的话，大概有 ${{20000} \over {20}}/{2^{{1 \over {12}}}}$ ≈120 个频率，时间精度按60帧算，即218.45\*60=13107个时间刻度，用一个二维数组表示，每个元素用 double 类型表示振幅，一共需要内存为 13107\*120\*sizeof(double)=12582720字节，即 12mb。上述算法中需要用到内存最大的地方是 sum_m_sin 这个数组，如果将一首音乐整个时段全求出 sum_m_sin 显然现代普通计算机内存远远不够，为此我们可以分段求出，用少量的时间代价换区高昂的空间代价，例如设计几十个周期为一段，占用内存就可忽略不计，时间代价也没有增加多少。
2. 下面来估计计算整首歌的时间复杂度，通过前面的讨论我们知道计算一个特定时刻特定频率的振幅的算法的时间复杂度为 O(${2^{MAX\_WIN\_N\_VIB\_P+MAX\_T\_SEG\_P}}$)，现在有FREQ_N=120个频率刻度和TIME_N=13107个时间刻度，将其乘起来最终时间复杂度为 O(${2^{MAX\_WIN\_N\_VIB\_P+MAX\_T\_SEG\_P}}*FREQ\_N*TIME\_N$) ，若 MAX_WIN_N_VIB_P 设为 5，MAX_T_SEG_P 设为 5，这样估计下来，计算次数为 ${2^{5 + 5}}*120*13107 = {\rm{1610588160}}$ ，可预测在普通机子的 CPU 下计算这一整首歌的频谱大概需要数秒到数分钟，现代机子不会超过两分钟。

上述思考只是假设一首 5 兆的 mp3 歌曲，要是某个 mp3 文件高达几十兆几百兆，那么无论占用内存还是计算时间，计算机勉强承受或者难以承受，所以尽量不考虑这种架构来实现。

### 第二种架构数据结构设计

设计一个管道数据结构，特点为容量有限，有两端，一端输入一端输出，将解码器、分析器、播放器全部分开为不同对象，管道用多态的方式分为音频文件原始数据管道、PCM样点数据管道、频谱数据管道。

再设计一个总的控制类，可以由用户随意控制时间播放停止进程，根据不同行为来读写管道内容，传递给或调用解码器、分析器或播放器来实现需求。

### 分析器的结构

为分析器设计输入接口、输出接口，输入接口用于给分析器传递PCM样点数据，输出接口用于控制类来读取频谱分析结果。

用一个随时运行的线程来检测输入，如果有了输入立马进行分析，经过一系列核心算法转换成可以输出的频谱分析结果。

由于有大量的浮点运算，所以为了确保效率，无论是样点还是分析得出的频谱振幅，都统一用 double 标准类型进行计算。

现在可以定义以下输入输出的数据结构类型：

1. 输入

   ```C++
   	struct {
   		size_t length;
   		double pcm[MAX_INPUT_LEN];
   	} m_input_pcm[2];
   ```
   
   由于输入是源源不断的，而计算一段时间的频谱需要依赖上一段时间的末尾处的某些样点，所以需要保存上一次的样点数据，所以代码中定义的输入的数组元素个数为 2，一个用于保存当前输入的样点，一个用于储存上一次输入的样点。
   
2. 输出

   ```c++
   double m_output_sepectrum[MAX_OUTPUT_LEN][FREQ_N];
   ```

   其中 FREQ_N 表示需要进行频谱分析的频率的个数，至于要分析哪些频率（20~20000HZ），可以在构造函数一开始就定义好。

   

## 算法流程设计

### 核心流程设计

算法的核心流程，都实现在线程函数里，是负责自动检测并读取输入，最终转化成输出的步骤。该函数的大体流程先后顺序如下：

1. 检测是否有输入，如果没有则 sleep 很短的时间再继续检测，循环检测直到有为止，如果一旦有，则往下进行第二步骤。

2. 对 20 到 20000HZ 中所有的半音对应的频率，即一共 120 个频率进行遍历循环执行后续步骤，用 i_freq 作为循环变量 0～119，表示当前频率对应的下标。

3. 将 m_input_pcm 中每个样点都分别与 i_freq 对应的频率的正弦和余弦函数进行乘积，将乘积的结果保存到一个数组 m_sin 中，即用 m_sin[f,i] 表示在 f 下标对应的频率中，pcm[i] 与 i_freq 对应的频率 sin函数对应的 i 位置的值的乘积，m_cos同理，注意一定要确保 sin 和 cos 函数的相位差值为 π/2。

4. 由 m_sin 构建一个累加结果的数组，即用 sum_m_sin[f,i,j] 表示在 f 下标对应的频率中，从 m_sin[f,i] 加到从 m_sin[f,i] 起一直到往后 j 个样点的总和，具体用递推算法实现。考虑到边界情况和方便后续计算，需要允许第一维的下标为负，至于能负到多少，由检测的频率宽度决定。

5. 计算平方和数组 q_sum[f,i,j] = sum_sin[f,i,j]²+sum_cos[f,i,j]²。

6. 分别求出每个振动次数中，移动窗口时得到的平方和的最大值。即 max_q_sum[f,i,k] = max{q_sum[f,x,k]}，x 遍历包含该 i 处的样点的所有窗口的窗口左边界。

7. 求出每个固定窗口移动时得到的频率振动幅度 v[f,i,k] = ${2 \over {N}}\sqrt {max\_q\_sum\left[ {f,i,k} \right]} $ ，其中 N 表示 ${2^k}$ 个周期窗口中所包含的样点数。

8. 求出所有振动次数对应的频率振动幅度的最小值，得出最终结果。即 m_output_sepectrum[i,f] = min{v[f,i,k]} ， 其中 k 遍历所有振动次数。

9. 将当前输入设为上一次输入，将实际的当前输入清空，然后回到第 1 步检测输入。





